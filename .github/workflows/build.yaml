name: Build and Push Docker Image to Docker Hub

env:
  IMAGE_NAME: erikpack/bitcoind
  IMAGE_TAG: 26.2

on: push
jobs:
  test:
    name: test that bitcoind builds and runs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source code
        uses: actions/checkout@v3

      - name: Run tests
        run: make test

  build_and_push_to_registry:
    name: push docker image to hub
    runs-on: ubuntu-latest
    needs: [ test ]
    steps:
      - name: check repository
        uses: actions/checkout@v4

      - name: login to docker registry
        uses: docker/login-action@v3
        with:
          username: erikpack
          password: ${{secrets.DOCKERHUB_TOKEN}}
      
      # attestations https://docs.docker.com/build/ci/github-actions/attestations/
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: build and push docker image to registry
        uses: docker/build-push-action@v6
        with:
          provenance: mode=max
          push: true
          tags: ${{ steps.meta.outputs.tags }}

  # deploy to kubernetes https://nicwortel.nl/blog/2022/continuous-deployment-to-kubernetes-with-github-actions
  # again this is not something you would normally do. CD tools are much better and safer way to do this. e.g. Argo/flux
  deploy:
    name: Deploy
    needs: [ test, build ]
    runs-on: ubuntu-latest
    steps:
      - name: Set the Kubernetes context
        uses: azure/k8s-set-context@v2
        with:
          method: service-account
          k8s-url: gke-autopilot-cluster
          k8s-secret: ${{ secrets.KUBERNETES_SECRET }}
  
      - name: Checkout source code
        uses: actions/checkout@v3

      - name: Deploy to the Kubernetes cluster
        uses: azure/k8s-deploy@v1
        with:
          namespace: default
          manifests: |
            ./k8s.yaml
          images: |
            ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        